TODO: 3-way parameters en 3-way factored parameters - veranderen er nog andere dingen?

TODO: gaussian units (sigma=1)

TODO: truncated exponential units

TODO: PCDStatsCollector (persistent CD)

TODO: wat glue code om RBMs te stacken in DBNs.
    - samplen van een DBN
    - DBN training (laag-per-laag)
    - DBN inference

TODO: passen autoencoders ook binnen dit raamwerk? mss moeten bepaalde dingen dan hernoemd worden...

TODO: docs: what are the different components and their roles, what are vmaps, umaps, dmaps, ..., and what are the interfaces the different components adhere to (f.e. the 'cd' keyword argument for samplers)
+ some common use cases + example usage for each feature (f.e. how to use momentum, how to construct a CD updater)

TODO: cleanup: remove some comments that are irrelevant

TODO: optimised 1D convolution    
    
TODO: test 1D convolution

TODO: dat FCRBM model voor modeling motion style eens proberen nabouwen!
  ook interessant hierbij: parameter tying! kan dit in het framework gepast worden?
  
TODO: gaussian units met learnt variance (gescheiden en samen)
  
TODO: symmetric beta units

TODO: in a conditional RBM (f.e. with visibles v, hiddens h and context x), CD won't work if the context variable isn't supplied. This is because CD will try to update the parameters tying h/v and x regardless of whether x was supplied as context. It would be nice if this didn't happen, i.e. when x is not supplied as context, all parameters tying x are simply ignored. This would also avoid some hard-to-decipher error messages.


- idee voor later: hierbij ook een 'chunking' framework voegen dat data in grote chunks kan omzetten voor efficient trainen op de GPU, + snapshotting







*** PRELIMINARY DOCUMENTATION ***

TRAINING

split into multiple phases:

- collect statistics, given input data and the model
  * for CD-k, this is input visibles, sampled hiddens, and then visibles and hiddens after k steps
  * for PCD, the negative term is different
- use statistics to compute the weight updates
  * for all types of CD, this is just getting the 'gradient' from the Parameters object and filling in the blanks.
- update the weights according to some other hyperparameterised settings (this is where momentum, weight decay etc. are)

ParamUpdater: composite object (possibly consisting of multiple other ParamUpdaters that are somehow combined (typical usecase: updates are summed)) that updates parameters given some input data

DecayParamUpdater: provides a decay term

MomentumParamUpdater: encapsulates another ParamUpdater and applies momentum to it

CDParamUpdater: encapsulates CD-k or PCD weight update computation
  * takes the input data, computes statistics by calling a StatsCollector on it
  * gets the form of the update term from the Parameters object, fills in the blanks with the stats from the StatsCollector
  * returns the resulting update
  
SparsityParamUpdater: encapsulates sparsity target regularisation

SumParamUpdater: sums the updates obtained from its child paramupdaters. should check that the composing ParamUpdaters are for the same Parameters!

ScaleParamUpdater: takes a ParamUpdater and a scale factor, and scales the updates by this factor. This will be the result of writing '0.005 * ParamUpdater()' for example.


StatsCollector: object that collects statistics (typically for CD), given input

CDStatsCollector(k) < StatsCollector: collects statistics for CD-k

PCDStatsCollector < StatsCollector: collects statistics for PCD

!! since only the negative term differs between CDStatsCollector and PCDStatsCollector, maybe some overlapping code can be factored out here.


update process:

- first, all ParamUpdaters (which each update ONLY ONE Parameters object) are inspected, and the StatsCollector objects they use are extracted: ParamUpdater.stats_collectors
- then iterate:
  * collect stats: run the extracted StatsCollectors (StatsCollector.collect() or something)
  * run ParamUpdaters
    - each ParamUpdater calls StatsCollector.stats
  * That way, each collector is only run once per update step, and all params are updated based on the same stats. We just need to make sure that they all hold a reference to the same StatsCollector object.


MODULAR RBM

v = a(f(W, h) + g(vbias))
h = a'(f'(W, v) + g'(hbias))

ActivationFunction
Sampler
Units

(unit data u + activation functions a(x) + samplers) = Units

Parameters(list<Units> units)
  has
    - list<Units>: list of units that are related by the parameters
    - a set of actual parameters (weights)
  provides
    - contribution to activation of each of the Units
    - contribution to the energy function

RBM
  has
    - list<Units>: a set of different types of units
    - list<Parameters>: a set of different types of parameters that relate the Units
  provides
    - sampling a type of units (computing nonlinear activation and sampling)
    - computing the energy function (summing the contributions for each of the Parameters)


get unit values (this goes for all unit types):
  - compute linear activation
      x = sum_i(f(W_i, u_i))
  - apply activation function  
      a(x)
  - sample
      u ~ a(x)
      
Computing a linear activation consists of summing all the contributions of the different Parameters

a Sampler can just be the identity function (mean field) or a bernoulli sampler (most common), a softmax sampler, a max-pooling sampler, ...


Units, ActivationFunction and Sampler are AWARE of the RBM they are part of - most of the logic is concentrated in the subclasses. while this does bring some dependencies that could technically be avoided, it should lead to a cleaner architecture.


implement a system where different types of units, weights and sampling can be combined easily. If it's performant that's a plus, but it doesn't have to be (mainly for experimentation). This will make it easier to construct heterogeneous models.

